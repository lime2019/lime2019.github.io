(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{633:function(e,t,a){"use strict";a.r(t);var s=a(2),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#vue-3-0-重要变更"}},[e._v("Vue 3.0 重要变更")]),a("ul",[a("li",[a("a",{attrs:{href:"#performance"}},[e._v("Performance")])]),a("li",[a("a",{attrs:{href:"#tree-shaking-support"}},[e._v("Tree-shaking support")])]),a("li",[a("a",{attrs:{href:"#composition-api"}},[e._v("Composition API")])]),a("li",[a("a",{attrs:{href:"#fragment-teleport-suspense"}},[e._v("Fragment, Teleport, Suspense")])]),a("li",[a("a",{attrs:{href:"#better-typescript-support"}},[e._v("Better TypeScript support")])])])]),a("li",[a("a",{attrs:{href:"#使用方式"}},[e._v("使用方式")]),a("ul",[a("li",[a("a",{attrs:{href:"#通过标签引入"}},[e._v("通过标签引入")])]),a("li",[a("a",{attrs:{href:"#脚手架工具创建"}},[e._v("脚手架工具创建")])])])]),a("li",[a("a",{attrs:{href:"#改动缘由"}},[e._v("改动缘由")])]),a("li",[a("a",{attrs:{href:"#基础api"}},[e._v("基础API")]),a("ul",[a("li",[a("a",{attrs:{href:"#createapp-方法"}},[e._v("createApp()方法")])]),a("li",[a("a",{attrs:{href:"#ref-方法"}},[e._v("ref()方法")])]),a("li",[a("a",{attrs:{href:"#reactive-方法"}},[e._v("reactive()方法")])]),a("li",[a("a",{attrs:{href:"#ref-和-reactive-区别"}},[e._v("ref() 和 reactive() 区别")])]),a("li",[a("a",{attrs:{href:"#setup-方法"}},[e._v("setup()方法")])]),a("li",[a("a",{attrs:{href:"#computed-方法"}},[e._v("computed() 方法")])]),a("li",[a("a",{attrs:{href:"#readonly-方法"}},[e._v("readonly 方法")])])])])])]),a("p"),e._v(" "),a("h2",{attrs:{id:"vue-3-0-重要变更"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-0-重要变更"}},[e._v("#")]),e._v(" Vue 3.0 重要变更")]),e._v(" "),a("p",[e._v("Vue 3.0 相对与之前的版本，有 6 个方面的重要变更：")]),e._v(" "),a("ul",[a("li",[e._v("Performance （性能）")]),e._v(" "),a("li",[e._v("Tree-shaking support （支持 Tree-shaking）")]),e._v(" "),a("li",[e._v("Composition API")]),e._v(" "),a("li",[e._v("Fragment, Teleport, Suspense")]),e._v(" "),a("li",[e._v("Better TypeScript support （更好的 TypeScript 支持度）")]),e._v(" "),a("li",[e._v("Custom Renderer API （自定义的 Renderer API）")])]),e._v(" "),a("h3",{attrs:{id:"performance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performance"}},[e._v("#")]),e._v(" Performance")]),e._v(" "),a("p",[e._v("性能上，主要有以下这五个方面：")]),e._v(" "),a("ul",[a("li",[e._v("Rewritten virtual dom implementation （重写了虚拟 DOM）")]),e._v(" "),a("li",[e._v("Compiler-informed fast paths （优化编译）")]),e._v(" "),a("li",[e._v("More efficient component initialization （更高效的组件初始化）")]),e._v(" "),a("li",[e._v("1.3-2x better update performance （1.3~2 倍的更新性能）")]),e._v(" "),a("li",[e._v("2-3x faster SSR （2~3 倍的 SSR 速度）")])]),e._v(" "),a("p",[e._v("性能上，主要是优化了虚拟 DOM，所以也就有了更加优化的编译，同时实现了更加高效的组件初始化。")]),e._v(" "),a("h3",{attrs:{id:"tree-shaking-support"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-support"}},[e._v("#")]),e._v(" Tree-shaking support")]),e._v(" "),a("ul",[a("li",[e._v("Most optional features （e.g. v-model, "),a("code",[e._v("<transition>")]),e._v("）are now tree-shakable （大多数可选功能（如 v-model、"),a("code",[e._v("<transition>")]),e._v("）现在都是支持 Tree-shaking 的。）")]),e._v(" "),a("li",[e._v("Bare-bone HelloWorld size: 13.5kb. 11.75kb with only Composition API support")]),e._v(" "),a("li",[e._v("All runtime features included: 22.5kb. More features but still lighter than Vue 2")])]),e._v(" "),a("p",[e._v("在大部分情况下，我们并不需要 vue 中的所有功能，但是在之前的 vue 版本中，我们没有一个合适的办法用来除去不需要的功能，而 Vue3 中，为了满足体积更小的需求，支持 Tree-shaking，也就意味着我们可以按需求引用的内置的指令和方法。")]),e._v(" "),a("h3",{attrs:{id:"composition-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#composition-api"}},[e._v("#")]),e._v(" Composition API")]),e._v(" "),a("ul",[a("li",[e._v("Usable alongside existing Options API （可与现有选项 API 一起使用）")]),e._v(" "),a("li",[e._v("Flexible logic composition and reuse （灵活的逻辑组成和重用）")]),e._v(" "),a("li",[e._v("Reactivity module can be used as a standalone library （Reactivity 模块可以作为独立的库使用）")])]),e._v(" "),a("p",[e._v("Composition API 主要是提高了代码逻辑的可复用性，并且将 Reactivity 模块独立出来，这也使得 vue 3 变得更加灵活地与其他框架组合使用。")]),e._v(" "),a("h3",{attrs:{id:"fragment-teleport-suspense"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragment-teleport-suspense"}},[e._v("#")]),e._v(" Fragment, Teleport, Suspense")]),e._v(" "),a("ul",[a("li",[e._v("Fragment\n"),a("ul",[a("li",[e._v("No longer limited to a single root node in templates （"),a("code",[e._v("<template>")]),e._v(" 中不再局限于单一的根节点）")]),e._v(" "),a("li",[e._v("Manual render functions can simply return Arrays （render 函数可以返回数组）")]),e._v(" "),a("li",[e._v("“Just works”")])])]),e._v(" "),a("li",[e._v("Teleport\n"),a("ul",[a("li",[e._v("Previously known as "),a("code",[e._v("<Portal>")]),e._v(" （原名为 "),a("code",[e._v("<Portal>")]),e._v("）")]),e._v(" "),a("li",[e._v("More details to be shared by @Linusborg")])])]),e._v(" "),a("li",[e._v("Suspense\n"),a("ul",[a("li",[e._v("Wait on nested async dependencies in a nested tree")]),e._v(" "),a("li",[e._v("Works with async "),a("code",[e._v("setup()")]),e._v(" （与 async 函数 "),a("code",[e._v("setup()")]),e._v(" 配合使用）")]),e._v(" "),a("li",[e._v("Works with Async Components （与 Async 组件配合使用）")])])])]),e._v(" "),a("h3",{attrs:{id:"better-typescript-support"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#better-typescript-support"}},[e._v("#")]),e._v(" Better TypeScript support")]),e._v(" "),a("ul",[a("li",[e._v("Codebase written in TS w/ auto-generated type definitions")]),e._v(" "),a("li",[e._v("API is the same in JS and TS")]),e._v(" "),a("li",[e._v("In fact, code will also be largely the same")]),e._v(" "),a("li",[e._v("TSX support")]),e._v(" "),a("li",[e._v("Class component is still supported （vue-class-component@next is currently in alpha）")])]),e._v(" "),a("p",[e._v("vue3.0 对 TS 的支持度更高了，同时也支持 TSX 的使用；API 在 JS 与 TS 中的使用相同；类组件仍然可用，但是需要我们引入 vue-class-component@next，该模块目前还处于 alpha 测试阶段。")]),e._v(" "),a("h2",{attrs:{id:"使用方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用方式"}},[e._v("#")]),e._v(" 使用方式")]),e._v(" "),a("blockquote",[a("p",[e._v("三种使用方式："),a("code",[e._v("<script>")]),e._v(" 标签引入、脚手架工具创建、从仓库克隆")])]),e._v(" "),a("h3",{attrs:{id:"通过标签引入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通过标签引入"}},[e._v("#")]),e._v(" 通过标签引入")]),e._v(" "),a("p",[e._v("标签引入有两种方式：")]),e._v(" "),a("ol",[a("li",[e._v("直接下载用"),a("code",[e._v("<script>")]),e._v("标签引入；")]),e._v(" "),a("li",[e._v("通过CDN引用；")])]),e._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("\x3c!--vue版本为3.0.0-beta.14 --\x3e")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("script")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("src")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')]),e._v("https://cdn.jsdelivr.net/npm/vue@3.0.0-beta.14/dist/vue.global.js"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),a("span",{pre:!0,attrs:{class:"token script"}}),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("</")]),e._v("script")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("h3",{attrs:{id:"脚手架工具创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#脚手架工具创建"}},[e._v("#")]),e._v(" 脚手架工具创建")]),e._v(" "),a("p",[e._v("可以使用脚手架工具 vue-cli 来初始化项目")]),e._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 安装脚手架工具")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("npm")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("install")]),e._v(" -g @vue/cli\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 查看脚手架安装是否成功")]),e._v("\nvue -V\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 创建项目，之后进行命令行交互")]),e._v("\nvue create vue-next-test\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("h2",{attrs:{id:"改动缘由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#改动缘由"}},[e._v("#")]),e._v(" 改动缘由")]),e._v(" "),a("blockquote",[a("p",[e._v("Vue团队为什么重新设计了"),a("code",[e._v("APP")]),e._v("的引导以及全局"),a("code",[e._v("API")]),e._v("？")])]),e._v(" "),a("p",[e._v("这是因为 Vue 2.x 版本中的一些全局 API 和配置会永久地改变全局状态，而这些改变会导致如下问题（参考"),a("a",{attrs:{href:"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0009-global-api-change.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Global API change RFC"),a("OutboundLink")],1),e._v("）：")]),e._v(" "),a("ol",[a("li",[e._v("全局配置很容易在测试过程中意外污染其他测试用例。用户需要谨慎地存储原始的全局配置，并在每次测试后恢复（例如重置"),a("code",[e._v("Vue.config.errorHandler")]),e._v("）。但是其中一些 API（如"),a("code",[e._v("Vue.use")]),e._v("、"),a("code",[e._v("Vue.mixin")]),e._v("）没有办法恢复其效果，这使得涉及插件的测试特别棘手。")]),e._v(" "),a("li",[e._v('这使同一页面上的多个有着不同全局配置的 "app" 之间很难共享同一副本的 Vue，如下代码：')])]),e._v(" "),a("h2",{attrs:{id:"基础api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础api"}},[e._v("#")]),e._v(" 基础API")]),e._v(" "),a("ul",[a("li",[e._v("Vue 3.0 使用了"),a("code",[e._v("createApp()")]),e._v("代替了"),a("code",[e._v("new Vue({})")]),e._v(";")]),e._v(" "),a("li",[e._v("Vue 3.0 使用"),a("code",[e._v("setup()")]),e._v("代替了"),a("code",[e._v("data()")]),e._v("以及"),a("code",[e._v("computed()")]),e._v("；")]),e._v(" "),a("li",[e._v("Vue 3.0 使用了"),a("code",[e._v("ref()")]),e._v("方法;")])]),e._v(" "),a("h3",{attrs:{id:"createapp-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createapp-方法"}},[e._v("#")]),e._v(" "),a("code",[e._v("createApp()")]),e._v("方法")]),e._v(" "),a("blockquote",[a("p",[e._v("调用 createApp 会返回一个新的 app 实例，该实例不会被应用到其他实例的任何全局配置污染。")])]),e._v(" "),a("p",[e._v('从技术上来说，Vue 2 并没有 "app" 的概念，Vue 2 中所定义的 app 只是通过'),a("code",[e._v("new Vue()")]),e._v("创建的根 Vue 实例，每个从同一个 Vue 构造函数创建的根实例都共享同一个全局配置，但当我们添加插件、mixins、全局配置等时，它们都会永久使全局状态突变，也就是上面提到的第二个问题。")]),e._v(" "),a("p",[e._v("针对此问题，在 Vue 3.0 中，引入了新的全局方法："),a("code",[e._v("createApp()")])]),e._v(" "),a("p",[e._v('调用这个方法，传递 Vue 实例定义对象，并将返回对象分配给一个变量 app。调用 createApp 会返回一个 app 实例， 每个 app 实例都会提供了一个 app context（上下文），由 app 实例挂载的整个组件树共享同一个 app context，这个 app context（上下文） 在 Vue 2.x 中提供了 "全局" 的配置。在新的 API 下，调用 createApp 会返回一个新的 app 实例，该实例不会被应用到其他实例的任何全局配置污染。')]),e._v(" "),a("p",[a("strong",[e._v("挂载")])]),e._v(" "),a("p",[e._v("就像在"),a("code",[e._v("Vue 2")]),e._v("中的"),a("code",[e._v("$mount")]),e._v("实例方法一样，我们将调用"),a("code",[e._v("app")]),e._v("上的 "),a("code",[e._v("mount")]),e._v("方法，并通过传递一个"),a("code",[e._v("CSS")]),e._v("选择器来表示挂载元素。")]),e._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[e._v("createApp(App).mount('#app');\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"ref-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref-方法"}},[e._v("#")]),e._v(" "),a("code",[e._v("ref()")]),e._v("方法")]),e._v(" "),a("p",[e._v("ref 函数传入一个值作为参数，返回一个基于该值的响应式 "),a("code",[e._v("Ref")]),e._v(" 对象，这个对象只包含一个 "),a("code",[e._v(".value")]),e._v(" 属性，该对象中的值一旦被改变和访问，都会被跟踪到，通过修改 "),a("code",[e._v("number.value")]),e._v(" 的值，可以触发模板的重新渲染，显示最新的值。")]),e._v(" "),a("p",[e._v("想要判断一个某个值是否为 "),a("code",[e._v("ref()")]),e._v(" 创建出来的对象，我们可以使用 "),a("code",[e._v("isRsf()")]),e._v(" 函数。")]),e._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[e._v("const { createApp, ref, isRef } = Vue;\n...\nconst n = isRef(number) ? number.value : number\n...\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("h3",{attrs:{id:"reactive-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactive-方法"}},[e._v("#")]),e._v(" "),a("code",[e._v("reactive()")]),e._v("方法")]),e._v(" "),a("p",[a("code",[e._v("reactive()")]),e._v("函数可以创建响应式对象，它主要是处理你的对象让它经过 Proxy 的加工变为一个响应式的对象。")]),e._v(" "),a("p",[e._v("可以使用 "),a("code",[e._v("toRefs()")]),e._v("函数来将 "),a("code",[e._v("reactive()")]),e._v(" 创建出来的响应式对象，转为普通对象，但是这个对象上的属性节点都是以 "),a("code",[e._v("ref()")]),e._v(" 类型的像是数据。")]),e._v(" "),a("p",[e._v("与 "),a("code",[e._v("toRefs()")]),e._v(" 相似，还可以使用 "),a("code",[e._v("toRef()")]),e._v(" 函数，它们之间的区别是 "),a("code",[e._v("toRef()")]),e._v(" 可以将 "),a("code",[e._v("reactive()")]),e._v(" 创建出来的响应式对象的其中一个属性转换为 "),a("code",[e._v("ref()")]),e._v(" 类型。")]),e._v(" "),a("h3",{attrs:{id:"ref-和-reactive-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ref-和-reactive-区别"}},[e._v("#")]),e._v(" "),a("code",[e._v("ref()")]),e._v(" 和 "),a("code",[e._v("reactive()")]),e._v(" 区别")]),e._v(" "),a("p",[a("code",[e._v("ref()")]),e._v("只为某一个数据提供响应式能力，而 "),a("code",[e._v("reactive()")]),e._v(" 是为整个对象赋予响应式能力。")]),e._v(" "),a("p",[a("code",[e._v("reactive()")]),e._v(" 包装的对象会有一个较为麻烦的点：在 return 的时候必须把整个 "),a("code",[e._v("reactive()")]),e._v(" 对象返回出去，同时在引用的时候也必须对整个对象进行引用而无法解构，否则这个对象内容的响应式能力将会丢失。所以官方提供了 "),a("code",[e._v("toRefs()")]),e._v(" 函数来为我们减少麻烦。只要使用 "),a("code",[e._v("toRefs()")]),e._v(" 把 "),a("code",[e._v("reactive()")]),e._v(" 对象包装一下，就能够通过解构单独使用它里面的内容了，而此时的内容也依然维持着响应式的特性。")]),e._v(" "),a("h3",{attrs:{id:"setup-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setup-方法"}},[e._v("#")]),e._v(" "),a("code",[e._v("setup()")]),e._v("方法")]),e._v(" "),a("p",[e._v("Vue 3.0 的标志功能就是 "),a("code",[e._v("Composition API")]),e._v("，其中 "),a("code",[e._v("setup()")]),e._v(" 是一个新的组件选项，为我们使用 Vue3 的 "),a("code",[e._v("Composition API")]),e._v(" 新特性提供了统一的入口。")]),e._v(" "),a("p",[e._v("创建组件实例时，"),a("code",[e._v("setup()")]),e._v(" 在初始 "),a("code",[e._v("props")]),e._v(" 解析后立即调用，"),a("code",[e._v("setup()")]),e._v(" 代替了 Vue 2.x 的生命周期函数 "),a("code",[e._v("beforeCreate()")]),e._v(" 与 "),a("code",[e._v("created()")]),e._v("。")]),e._v(" "),a("blockquote",[a("p",[e._v("创建组件实例时，setup() 在初始 props 解析后立即调用；在生命周期方面，它在 beforeCreate() 挂载之后，created()之前被执行调用。"),a("br"),e._v("\n在 setup() 里的方法不能通过 this 来访问实例上的数据，而是通过直接读取 data 来访问。")])]),e._v(" "),a("p",[a("code",[e._v("setup()")]),e._v(" 返回一个对象，对象中的属性将直接暴露给模板渲染的上下文。而在 Vue2.x 中，定义的属性都会被 Vue 内部无条件暴露给模板渲染上下文。")]),e._v(" "),a("p",[e._v("另外 setup 方法不仅可以代替 data 和计算属性 computed，还可以代替 method 方法。")]),e._v(" "),a("p",[a("code",[e._v("setup()")]),e._v("方法接受两个参数：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("props")]),e._v(" "),a("blockquote",[a("p",[e._v("setup() 函数接收的第一个参数是 props，等同于 vue2 的 props，")])]),e._v(" "),a("p",[e._v("注意：解构参数会使参数失去"),a("strong",[e._v("响应性")]),e._v("。")])]),e._v(" "),a("li",[a("p",[e._v("context")]),e._v(" "),a("blockquote",[a("p",[e._v("第二个参数是上下文对象，他暴露了一个有选择的属性列表。")])])])]),e._v(" "),a("h3",{attrs:{id:"computed-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-方法"}},[e._v("#")]),e._v(" "),a("code",[e._v("computed()")]),e._v(" 方法")]),e._v(" "),a("p",[a("code",[e._v("computed()")]),e._v(" 用来创建计算属性，"),a("code",[e._v("computed()")]),e._v(" 函数的返回值是一个 "),a("code",[e._v("ref")]),e._v(" 的实例，主要注意使用 "),a("code",[e._v("computed()")]),e._v(" 之前需要按需导入:")]),e._v(" "),a("div",{staticClass:"language-html line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[e._v("const { computed } = Vue;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[a("code",[e._v("computed()")]),e._v(" 既可以创建只读的计算属性，还可以创建可读可写的计算属性。")]),e._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 创建只读计算属性")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" plusCount "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("computed")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("value "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 创建可读可写的计算属性")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 创建一个 ref 响应式数据")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" count "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("ref")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 创建一个 computed 计算属性")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" plusCount "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("computed")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 取值函数")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("get")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 赋值函数")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("set")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("val")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("value "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" val "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br")])]),a("h3",{attrs:{id:"readonly-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#readonly-方法"}},[e._v("#")]),e._v(" "),a("code",[e._v("readonly")]),e._v(" 方法")]),e._v(" "),a("p",[e._v("这个函数可以把普通 object 对象、reactive 对象、ref 对象返回一个只读对象。")])])}),[],!1,null,null,null);t.default=r.exports}}]);